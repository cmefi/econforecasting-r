# Set Constants
```{r}
DIR = 'D:/Onedrive/__Projects/econforecasting'
PACKAGE_DIR = 'D:/Onedrive/__Projects/econforecasting/econforecasting'
DL_DIR = 'D:/Onedrive/__Projects/econforecasting/tmp'
RESET_ALL = FALSE
```


# Initialize
```{r}
library(tidyverse)
library(devtools)
library(jsonlite)
library(lubridate)
library(httr)
library(rvest)
library(DBI)
library(data.table)

setwd(DIR)

if (dir.exists(DL_DIR)) unlink(DL_DIR, recursive = TRUE)
dir.create(DL_DIR, recursive = TRUE)

source(file.path(DIR, 'constants.r'))
CONST$PARAMS = readxl::read_excel('inputs.xlsx')

devtools::load_all(path = PACKAGE_DIR)
devtools::document(PACKAGE_DIR)

ef = list(
  h = list(),
  f = list()
)
```


# Get Historical Data

## From FRED
```{r}
local({
  
	# Run in console to get list of GDP subcomponents
	# httr::GET('https://fred.stlouisfed.org/release/tables?rid=53&eid=14961#snid=14966') %>%
	# 	httr::content(.) %>%
	# 	rvest::html_nodes('#release-elements-tree tbody tr') %>%
	# 	map_dfr(., function(x)
	# 		tibble(
	# 			a =
	# 				x %>% rvest::html_nodes('td') %>% .[3] %>%
	# 				html_text(.) %>% str_replace_all(., '\n', '') %>% trimws(.),
	# 			fred =
	# 				x %>% rvest::html_nodes('td') %>% .[3] %>%
	# 				rvest::html_nodes('span a') %>% rvest::html_attr('href') %>% str_replace(., '/series/', '')
	# 			)
	# 		)
	
	df =
		CONST$PARAMS %>%
		purrr::transpose(.) %>%
		setNames(., lapply(., function(x) x$varname)) %>%
		lapply(., function(x) {
		  message('Getting data ... ', x$varname)
		  econforecasting::getDataFred(x$fredname, CONST$FRED_API_KEY, .freq = 'q', .returnVintages = FALSE) %>%
		    dplyr::mutate(., varname = x$varname, freq = 'q') %>%
		    {if (x$freq %in% c('d', 'm'))
		      dplyr::bind_rows(
		        .,
		        econforecasting::getDataFred(x$fredname, CONST$FRED_API_KEY, .freq = 'm', .returnVintages = FALSE) %>%
		          dplyr::mutate(., varname = x$varname, freq = 'm')
		        )
		      else .
		    } %>%
		    {if (x$freq %in% c('d'))
		      dplyr::bind_rows(
		        .,
		        econforecasting::getDataFred(x$fredname, CONST$FRED_API_KEY, .freq = 'd', .returnVintages = FALSE) %>%
		          dplyr::mutate(., varname = x$varname, freq = 'd')
		        )
		      else .
		    }
		}) %>%
		dplyr::bind_rows(.) %>%
		dplyr::filter(., obsDate >= as.Date('2000-01-01'))


	ef$h$source$fred <<- df
})
```

## Aggregate raw data
```{r}
local({
	ef$h$sourceDf <<- dplyr::bind_rows(ef$h$source)
})
```

# Seasonal & Stationary Transformations

## Deseasonalize
```{r}
local({
	
	seasDf =
		ef$h$sourceDf %>%
		dplyr::filter(., varname == 'hpils') %>%
		dplyr::mutate(
			.,
			seas = 
			{ts(.$value, start = c(year(.$obsDate[1]), month(.$obsDate[1])), freq = 12)} %>%
			seasonal::seas(.) %>%
			predict(.)
			) %>%
		dplyr::select(., -value)
	
	df =
		dplyr::left_join(ef$h$sourceDf, seasDf, by = c('obsDate', 'varname', 'freq')) %>%
		dplyr::mutate(., value = ifelse(is.na(seas), value, seas)) %>%
		dplyr::select(., -seas)

	ef$h$seasDf <<- df
})
```

## Stationary transformations
```{r}
local({

	flat = list()
	flat$base = ef$h$seasDf
	
	flat$stat =
		ef$h$seasDf %>%
		dplyr::left_join(., CONST$PARAMS[, c('varname', 'stat_transform')], by = c('varname')) %>%
		dplyr::group_by(varname, freq) %>%
		dplyr::group_split(.) %>%
		lapply(., function(x)
			x %>%
				dplyr::arrange(., obsDate) %>%
				dplyr::mutate(
					.,
					value = {
						if (head(., 1)$stat_transform == 'base') value
						else if (head(., 1)$stat_transform == 'dlog') dlog(value)
						else if (head(., 1)$stat_transform == 'diff1') diff1(value)
						else if (head(., 1)$stat_transform == 'diff2') diff2(value)
						else if (head(., 1)$stat_transform == 'ma2') ma2(value)
						else if (head(., 1)$stat_transform == 'lma2') lma2(value)
						else if (head(., 1)$stat_transform == 'apchg') apchg(value)
						else stop ('Error')
						}
					)
			) %>%
		dplyr::bind_rows(.) %>%
		dplyr::select(., -stat_transform)
	
	
	
	ef$h$flat <<- flat
	ef$h$flatDf <<- purrr::imap_dfr(flat, function(x, transform) x %>% mutate(., transform = transform)) 
})
```

## Create monthly/quarterly matrixes
```{r}
local({
	
	wide =
		ef$h$flatDf %>%
		as.data.table(.) %>%
		split(., by = 'freq') %>%
		lapply(., function(x)
			split(x, by = 'transform') %>%
				lapply(., function(y)
					as_tibble(y) %>%
						dplyr::select(., -freq, -transform) %>%
						tidyr::pivot_wider(., names_from = varname)
					)
			)
	
# dplyr::inner_join(ef$h$wide$q$stat, ef$nc$fDf, by = 'obsDate') %>%  dplyr::filter(., obsDate >= as.Date('2010-01-01')) %>%	lm(pdinr ~ f1 + f2 + f3 + f4 + f5, data = .) %>% residuals(.) %>% {. * 400}
	
	ef$h$wide <<- wide	
})
```


# Nowcast

## Get dates
```{r}
local({
	
	pcaVarnames = CONST$PARAMS %>% dplyr::filter(., dfminput == TRUE) %>% .$varname
	
	fullPcaData =
		ef$h$wide$m$stat %>%
		dplyr::select(., obsDate, all_of(pcaVarnames)) %>%
		dplyr::filter(., obsDate >= as.Date('2012-01-01'))
	
	bigTDates = fullPcaData %>% dplyr::filter(., !if_any(everything(), is.na)) %>% .$obsDate
	bigTauDates = fullPcaData %>% dplyr::filter(., if_any(everything(), is.na)) %>% .$obsDate

	
	ef$nc$pcaVarnames <<- pcaVarnames
	ef$nc$bigTDates <<- bigTDates
	ef$nc$bigTauDates <<- bigTauDates
})
```

## Extract factors
```{r}
local({
	
	xDf =
		ef$h$wide$m$stat %>%
		dplyr::filter(., obsDate %in% ef$nc$bigTDates) %>%
		dplyr::select(., obsDate, pcaVarnames)
	
	xMat =
		xDf %>%
		dplyr::select(., -obsDate) %>%
		as.matrix(.) %>%
		scale(.)
	
	lambdaHat = eigen(t(xMat) %*% xMat) %>% .$vectors
	fHat = (xMat) %*% lambdaHat
	
	# Total variance of data
	totalVar = xMat %>% cov(.) %>% diag(.) %>% sum(.)
	
	# Explained variance of data
	varDf =
		fHat %>% cov(.) %>% diag(.) %>%
		{lapply(1:length(.), function(i)
			tibble(
				factor = i,
				var_explained = .[i],
				pct_of_total = .[i]/totalVar,
				cum_pct_of_total = sum(.[1:i])/totalVar
				)
			)} %>%
		dplyr::bind_rows(.)
	
	bigR =
		varDf %>%
		dplyr::filter(cum_pct_of_total >= .90) %>%
		head(., 1) %>%
		.$factor
	
	
	zDf =
		xDf[, 'obsDate'] %>%
		dplyr::bind_cols(
			.,
			fHat[, 1:bigR] %>% as.data.frame(.) %>% setNames(., paste0('f', 1:bigR))
			)
	
	ef$nc$bigR <<- bigR
	ef$nc$pcaInputDf <<- xDf
	ef$nc$zDf <<- zDf
})
```

## Run as VAR(1)
```{r}
local({
	
	inputDf =
		ef$nc$zDf %>%
    	econforecasting::addLags(., 1, TRUE) %>%
		na.omit(.)
	yMat = inputDf %>% dplyr::select(., -contains('.l'), -obsDate) %>% as.matrix(.)
	xDf = inputDf %>% dplyr::select(., contains('.l')) %>% dplyr::bind_cols(constant = 1, .)
	
	# solve(t(xMat) %*% xMat) %*% (t(xMat) %*% yMat)
	coefDf =
		lm(yMat ~ . - 1, data = xDf) %>%
		coef(.) %>%
		as.data.frame(.) %>%
		rownames_to_column(., 'coefname') %>%
		as_tibble(.) 
	
	bMat = coefDf %>% dplyr::filter(., coefname != 'constant') %>% dplyr::select(., -coefname) %>% t(.)
	cMat = coefDf %>% dplyr::filter(., coefname == 'constant') %>% dplyr::select(., -coefname) %>% t(.)
	qMat =
		lm(yMat ~ . - 1, data = xDf) %>%
	    residuals(.) %>% 
		as_tibble(.) %>%
		purrr::transpose(.) %>%
		lapply(., function(x) as.numeric(x)^2 %>% diag(.)) %>%
		{purrr::reduce(., function(x, y) x + y)/length(.)}
	
	
	ef$nc$qMat <<- qMat 
	ef$nc$bMat <<- bMat
	ef$nc$cMat <<- cMat
})
```

## Run DFM on monthly variables included in PCA
```{r}
local({
	
	yMat = ef$nc$pcaInputDf %>% dplyr::select(., -obsDate) %>% as.matrix(.)
	xDf = ef$nc$zDf %>% dplyr::select(., -obsDate)
	
	coefDf =
		lm(yMat ~ . - 1, xDf) %>%
		coef(.) %>%	
		as.data.frame(.) %>%
    	rownames_to_column(., 'coefname') %>%
		as_tibble(.)
	
	aMat = coefDf %>% dplyr::select(., -coefname) %>% t(.)
	
	rMat0 =
		lm(yMat ~ . - 1, data = xDf) %>%
	    residuals(.) %>% 
		as_tibble(.) %>%
		purrr::transpose(.) %>%
		lapply(., function(x) as.numeric(x)^2 %>% diag(.)) %>%
		{purrr::reduce(., function(x, y) x + y)/length(.)}
	
	rMatDiag = tibble(varname = ef$nc$pcaVarnames, variance = diag(rMat0))

	
	rMats =
		lapply(ef$nc$bigTauDates, function(d)
			sapply(ef$nc$pcaVarnames, function(v)
				ef$h$wide$m$stat %>%
					dplyr::filter(., obsDate == (d)) %>%
					.[[v]] %>% 
					{if (is.na(.)) 1e20 else dplyr::filter(rMatDiag, varname == v)$variance}
				) %>%
				diag(.)
			) %>%
		c(lapply(1:length(ef$nc$bigTDates), function(x) rMat0), .)

	ef$nc$rMats <<- rMats
	ef$nc$aMat <<- aMat
})
```

## Build state space variables
```{r}
local({
	
	bMat = ef$nc$bMat
	cMat = ef$nc$cMat
	aMat = ef$nc$aMat
	rMats = ef$nc$rMats
	qMat = ef$nc$qMat
	yMats =
		dplyr::bind_rows(
			ef$nc$pcaInputDf,
			ef$h$wide$m$stat %>%
				dplyr::filter(., obsDate %in% ef$nc$bigTauDates) %>%
				dplyr::select(., obsDate, pcaVarnames)
			) %>%
		dplyr::mutate(., across(-obsDate, function(x) ifelse(is.na(x), 0, x))) %>%
		dplyr::select(., -obsDate) %>%
		purrr::transpose(.) %>%
		lapply(., function(x) matrix(unlist(x), ncol = 1))

	z0Cond0 = matrix(rep(0, ef$nc$bigR), ncol = 1)
	sigmaZ0Cond0 = matrix(rep(0, ef$nc$bigR^2), ncol = ef$nc$bigR)
		
	zTCondTMinusOne = list()
	zTCondT = list()
	
	sigmaZTCondTMinusOne = list()
	sigmaZTCondT = list()
	
	yTCondTMinusOne = list()
	sigmaYTCondTMinusOne = list()
	
	pT = list()

	for (t in 1:length(c(ef$nc$bigTDates, ef$nc$bigTauDates))) {
		message(t)
		# Prediction Step
		zTCondTMinusOne[[t]] = bMat %*% {if (t == 1) z0Cond0 else zTCondT[[t-1]]} + cMat
		sigmaZTCondTMinusOne[[t]] = bMat %*% {if (t == 1) sigmaZ0Cond0 else sigmaZTCondT[[t-1]]} + qMat
		yTCondTMinusOne[[t]] = aMat %*% zTCondTMinusOne[[t]]
		sigmaYTCondTMinusOne[[t]] = aMat %*% sigmaZTCondTMinusOne[[t]] %*% t(aMat) + rMats[[t]]
		
		# Correction Step
		pT[[t]] = sigmaZTCondTMinusOne[[t]] %*% t(aMat) %*%
			{if (t %in% 1:length(ef$nc$bigTDates)) solve(sigmaYTCondTMinusOne[[t]]) else chol2inv(chol(sigmaYTCondTMinusOne[[t]]))}
		zTCondT[[t]] = zTCondTMinusOne[[t]] + pT[[t]] %*% (yMats[[t]] - yTCondTMinusOne[[t]])
		sigmaZTCondT[[t]] = sigmaZTCondTMinusOne[[t]] - (pT[[t]] %*% sigmaYTCondTMinusOne[[t]] %*% t(pT[[t]]))
	}
	
	
	kFitted =
		zTCondT %>% purrr::map_dfr(., function(x) as.data.frame(x) %>% t(.) %>% as_tibble(.)) %>% dplyr::bind_cols(obsDate = c(ef$nc$bigTDates, ef$nc$bigTauDates), .) 
	
	
	dplyr::bind_rows(dplyr::mutate(ef$nc$zDf, type = 'historical'), dplyr::mutate(kFitted, type = 'fitted')) %>% tidyr::pivot_longer(., -c('obsDate', 'type'), names_to = 'varname') %>% dplyr::filter(., varname == 'f1') %>% ggplot(.) + geom_line(aes(x = obsDate, y = value, color = type))
})
```



Get monthly versions of GDP subcomponents ->
	Using DFM on some, SEM on others. Divide by 3 to get "monthly" dlog estimates -> loop through each quarter, adjust all monthly dlog values such that all dlog values must sumn correctly. ((1+m1+x)(1+m2+x)(1+m3+x) = (1+q)) => Solve for x. Get all base values
	
-> after monthly calcs, can 
	
	dlog.gdp = dlog.pce * pce_1/gdp_1 + dlog.gpdi * gpdi/gpdi_1 + dlog.exports * exports1/gdp + dlog.gvt * gvt/gdp
dplyr::filter(ef$h$wide$q$stat, obsDate >= as.Date('2010-01-01')) %>% lm(pdinr ~ (pce) + ma2(ue) + ma2(vsales) + ma2(spy) + lma2(loanscc), data = .) %>% summary(.)

-> convert to ma2



dplyr::filter(ef$h$wide$q$stat, obsDate >= as.Date('2010-01-01')) %>% lm(gdp ~ pce + ue + vsales, data = .) %>% residuals(.) %>% dplyr::bind_cols( dplyr::filter(ef$h$wide$q$stat, obsDate >= as.Date('2010-01-01')), resids = .) %>% dplyr::transmute(., obsDate,  gdp = gdp * 400, pce = pce * 400, ue, resids = resids * 400) %>% View(.)



-> first estim ate components of GDP monthly


```{r}
local({
	
	lm(as.matrix(yDf) ~ ., data = xDf[, 1:6]) %>% residuals(.) %>% plot(.)
	
	ef$h$wide$q$base %>%
    	dplyr::filter(., obsDate >= as.Date('2010-01-01')) %>% lm(gdp ~ pce + ue, data = .) %>% summary(.)
})
```

## Get monthly versions of quarterly factors
```{r}
local({
	
	
	coefDf =
		dplyr::filter(ef$h$wide$q$stat, obsDate >= as.Date('2010-01-01')) %>%
		lm(pdinr ~ (pce) + ma2(ue) + ma2(vsales) + ma2(spy), data = .) %>%
		coefficients(.) %>%
		as.data.frame(.) %>%
		tibble::rownames_to_column(.) %>%
		as_tibble(.) %>%
		setNames(., c('varname', 'coefficient'))
	
	
})
```


```{r}
local({
fDf %>% dplyr::mutate(., quarter = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))) %>% dplyr::select(., -obsDate) %>% pivot_longer(., -quarter) %>% dplyr::group_by(quarter, name) %>% summarize(., value = mean(value)) %>% tidyr::pivot_wider(., names_from = name, values_from = value) %>% ungroup(.) %>% dplyr::inner_join(., ef$h$wide$q$stat[, c('obsDate', 'gdp')], by = c('quarter' = 'obsDate'))
})
```



##  
```{r}
local({
	# Aggregate factors by quarter and then 
	quarterlyFDf =
		fDf %>%
		dplyr::mutate(
			.,
			quarter = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))
			) %>%
		dplyr::select(., -obsDate) %>%
		pivot_longer(., -quarter) %>%
		dplyr::group_by(quarter, name) %>%
		dplyr::summarize(., value = mean(value)) %>%
		tidyr::pivot_wider(., names_from = name, values_from = value) %>%
		dplyr::ungroup(.)
	
	
	
	CONST$PARAMS %>% dplyr::filter(., freq == 'q') %>% .$varname %>% as.list(.) %>%
		lapply(., function(x) {
			inputDf =
				ef$h$wide$q$stat[, c('obsDate', x)] %>%
				dplyr::inner_join(., quarterlyFDf, by = c('obsDate' = 'quarter')) %>%
				dplyr::mutate(., lag := lag(.[[x]], 1)) %>% 
				na.omit(.)
			
			yDf = inputDf %>% dplyr::select(., all_of(x))
			xDf = inputDf %>% dplyr::select(., -c('obsDate', x))

			lm(as.matrix(yDf) ~ ., data = xDf[, 1:5]) %>% residuals(.) %>% plot(.)
			})
	
	lm(as.matrix(yDf) ~ ., data = xDf[, 1:5]) %>% residuals(.) %>% plot(.)

	
})
```


## Determine dates to be nowcasted & forecasted
```{r}
local({
	
	ef$h$fred %>%
		dplyr::group_by(varname) %>%
		dplyr::filter(., obsDate == max(obsDate) & freq == 'm') %>%
		dplyr::left_join(., dplyr::select(CONST$PARAMS, varname, key_input), by = 'varname') %>%
		dplyr::filter(., key_input == TRUE) %>%
		dplyr::ungroup(.)
	
fDf %>% dplyr::mutate(., quarter = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))) %>% dplyr::select(., -obsDate) %>% pivot_longer(., -quarter) %>% dplyr::group_by(quarter, name) %>% summarize(., value = mean(value)) %>% tidyr::pivot_wider(., names_from = name, values_from = value) %>% ungroup(.) %>% dplyr::inner_join(., ef$h$wide$q$stat[, c('obsDate', 'gdp')], by = c('quarter' = 'obsDate')) %>% dplyr::select(., -quarter) %>% lm(gdp ~ lma2(gdp) + ., data = .) %>% summary(.)

})
```


## De-seasonalize
```{r}
local({
	
	getDataFred('MEDLISPRIUS', CONST$FRED_API_KEY) %>% {ts(.$value, start = c(year(.$obsDate[1]), month(.$obsDate[1])), freq = 12)} %>% seasonal::seas(.) %>% predict(.) %>% as_tibble(.) %>% plot(.)

})
```

