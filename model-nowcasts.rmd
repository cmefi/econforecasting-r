# Set Constants
```{r}
DIR = 'D:/Onedrive/__Projects/econforecasting'
PACKAGE_DIR = 'D:/Onedrive/__Projects/econforecasting/econforecasting'
DL_DIR = 'D:/Onedrive/__Projects/econforecasting/tmp'
RESET_ALL = FALSE
```


# Initialize
```{r}
library(tidyverse)
library(devtools)
library(jsonlite)
library(lubridate)
library(httr)
library(rvest)
library(DBI)
library(data.table)

setwd(DIR)

if (dir.exists(DL_DIR)) unlink(DL_DIR, recursive = TRUE)
dir.create(DL_DIR, recursive = TRUE)

source(file.path(DIR, 'constants.r'))
CONST$PARAMS = readxl::read_excel('inputs.xlsx')

devtools::load_all(path = PACKAGE_DIR)
devtools::document(PACKAGE_DIR)

ef = list(
  h = list(),
  f = list()
)
```


# Get Historical Data

## From FRED
```{r}
local({
  
	# Run in console to get list of GDP subcomponents
	# httr::GET('https://fred.stlouisfed.org/release/tables?rid=53&eid=14961#snid=14966') %>%
	# 	httr::content(.) %>%
	# 	rvest::html_nodes('#release-elements-tree tbody tr') %>%
	# 	map_dfr(., function(x)
	# 		tibble(
	# 			a =
	# 				x %>% rvest::html_nodes('td') %>% .[3] %>%
	# 				html_text(.) %>% str_replace_all(., '\n', '') %>% trimws(.),
	# 			fred =
	# 				x %>% rvest::html_nodes('td') %>% .[3] %>%
	# 				rvest::html_nodes('span a') %>% rvest::html_attr('href') %>% str_replace(., '/series/', '')
	# 			)
	# 		)
	
	df =
		CONST$PARAMS %>%
		dplyr::filter(., source == 'fred') %>%
		purrr::transpose(.) %>%
		setNames(., lapply(., function(x) x$varname)) %>%
		lapply(., function(x) {
		  message('Getting data ... ', x$varname)
		  econforecasting::getDataFred(x$sckey, CONST$FRED_API_KEY, .freq = 'q', .returnVintages = FALSE) %>%
		    dplyr::mutate(., varname = x$varname, freq = 'q') %>%
		    {if (x$freq %in% c('d', 'm'))
		      dplyr::bind_rows(
		        .,
		        econforecasting::getDataFred(x$sckey, CONST$FRED_API_KEY, .freq = 'm', .returnVintages = FALSE) %>%
		          dplyr::mutate(., varname = x$varname, freq = 'm')
		        )
		      else .
		    } %>%
		    {if (x$freq %in% c('d'))
		      dplyr::bind_rows(
		        .,
		        econforecasting::getDataFred(x$sckey, CONST$FRED_API_KEY, .freq = 'd', .returnVintages = FALSE) %>%
		          dplyr::mutate(., varname = x$varname, freq = 'd')
		        )
		      else .
		    }
		}) %>%
		dplyr::bind_rows(.) %>%
		dplyr::filter(., obsDate >= as.Date('2000-01-01'))


	ef$h$source$fred <<- df
})
```

## Yahoo Finance
```{r}
local({
	
	url =
		paste0(
			'https://query1.finance.yahoo.com/v7/finance/download/', '%5EGSPC',
			'?period1=', '946598400', # 12/30/1999
			'&period2=', as.numeric(as.POSIXct(Sys.Date() + lubridate::days(1))),
			'&interval=1d',
			'&events=history&includeAdjustedClose=true'
		)

	df0 =
		data.table::fread(url) %>%
		.[, c('Date', 'Adj Close')]	%>%
		setnames(., new = c('obsDate', 'value')) %>%
		as_tibble(.)
	
	qDf = 
		df0 %>%
		dplyr::mutate(
			.,
			obsDate = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))
			) %>%
		dplyr::group_by(., obsDate) %>%
		dplyr::summarize(., value = mean(value), .groups = 'drop') %>%
		dplyr::mutate(., freq = 'q')
	
	mDf =
		df0 %>%
		dplyr::mutate(
			.,
			obsDate = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'M', lubridate::month(obsDate)))
			) %>%
		dplyr::group_by(., obsDate) %>%
		dplyr::summarize(., value = mean(value), .groups = 'drop') %>%
		dplyr::mutate(., freq = 'm')

	df =
		dplyr::bind_rows(mDf, qDf) %>%
		dplyr::mutate(., varname = 'spy')

	ef$h$source$yahoo <<- df
})
```


## Aggregate raw data
```{r}
local({
	ef$h$sourceDf <<- dplyr::bind_rows(ef$h$source)
})
```


# Seasonal & Stationary Transformations

## Deseasonalize
```{r}
local({
	
	seasDf =
		ef$h$sourceDf %>%
		dplyr::filter(., varname == 'hpils') %>%
		dplyr::mutate(
			.,
			seas = 
			{ts(.$value, start = c(year(.$obsDate[1]), month(.$obsDate[1])), freq = 12)} %>%
			seasonal::seas(.) %>%
			predict(.)
			) %>%
		dplyr::select(., -value)
	
	df =
		dplyr::left_join(ef$h$sourceDf, seasDf, by = c('obsDate', 'varname', 'freq')) %>%
		dplyr::mutate(., value = ifelse(is.na(seas), value, seas)) %>%
		dplyr::select(., -seas)

	ef$h$seasDf <<- df
})
```

## Stationary transformations
```{r}
local({

	flat = list()
	flat$base = ef$h$seasDf
	
	flat$stat =
		ef$h$seasDf %>%
		dplyr::left_join(., CONST$PARAMS[, c('varname', 'stat')], by = c('varname')) %>%
		dplyr::group_by(varname, freq) %>%
		dplyr::group_split(.) %>%
		lapply(., function(x)
			x %>%
				dplyr::arrange(., obsDate) %>%
				dplyr::mutate(
					.,
					value = {
						if (head(., 1)$stat == 'base') value
						else if (head(., 1)$stat == 'dlog') dlog(value)
						else if (head(., 1)$stat == 'diff1') diff1(value)
						else if (head(., 1)$stat == 'diff2') diff2(value)
						else if (head(., 1)$stat == 'ma2') ma2(value)
						else if (head(., 1)$stat == 'lma2') lma2(value)
						else if (head(., 1)$stat == 'apchg') apchg(value)
						else stop ('Error')
						}
					)
			) %>%
		dplyr::bind_rows(.) %>%
		dplyr::select(., -stat)
	
	
	
	ef$h$flat <<- flat
	ef$h$flatDf <<- purrr::imap_dfr(flat, function(x, transform) x %>% mutate(., transform = transform)) 
})
```

## Create monthly/quarterly matrixes
```{r}
local({
	
	wide =
		ef$h$flatDf %>%
		as.data.table(.) %>%
		split(., by = 'freq') %>%
		lapply(., function(x)
			split(x, by = 'transform') %>%
				lapply(., function(y)
					as_tibble(y) %>%
						dplyr::select(., -freq, -transform) %>%
						tidyr::pivot_wider(., names_from = varname) %>%
						dplyr::arrange(., obsDate)
					)
			)
	
	ef$h$wide <<- wide	
})
```


# Nowcast

## Get dates
```{r}
local({
	
	quartersForward = 1
	
	pcaVarnames = CONST$PARAMS %>% dplyr::filter(., dfminput == TRUE) %>% .$varname
	
	pcaVariablesDf =
		ef$h$wide$m$stat %>%
		dplyr::select(., obsDate, all_of(pcaVarnames)) %>%
		dplyr::filter(., obsDate >= as.Date('2010-01-01'))
	
	bigTDates = pcaVariablesDf %>% dplyr::filter(., !if_any(everything(), is.na)) %>% .$obsDate
	bigTauDates = pcaVariablesDf %>% dplyr::filter(., if_any(everything(), is.na)) %>% .$obsDate
	bigTStarDates =
		bigTauDates %>%
		tail(., 1) %>%
		seq(
			from = .,
			to =
				# Get this quarter
				econforecasting::strdateToDate(paste0(lubridate::year(.), 'Q', lubridate::quarter(.))) %>%
				# Get next quarter minus a month
				lubridate::add_with_rollback(., months(3 * (1 + quartersForward) - 1)),
			by = '1 month'
			) %>%
		.[2:length(.)]

	
	ef$nc$pcaVariablesDf <<- pcaVariablesDf
	ef$nc$pcaVarnames <<- pcaVarnames
	ef$nc$quartersForward <<- quartersForward
	ef$nc$bigTDates <<- bigTDates
	ef$nc$bigTauDates <<- bigTauDates
	ef$nc$bigTStarDates <<- bigTStarDates
})
```

## Extract factors
```{r}
local({
	
	xDf = ef$nc$pcaVariablesDf %>% dplyr::filter(., obsDate %in% ef$nc$bigTDates)
	
	xMat =
		xDf %>%
		dplyr::select(., -obsDate) %>%
		as.matrix(.) %>%
		scale(.)
	
	lambdaHat = eigen(t(xMat) %*% xMat) %>% .$vectors
	fHat = (xMat) %*% lambdaHat
	bigN = ncol(xMat)
	bigT = nrow(xMat)
	bigCSquared = min(bigN, bigT)
	
	# Total variance of data
	totalVar = xMat %>% cov(.) %>% diag(.) %>% sum(.)
	
	# Calculate ICs from Bai and Ng (2002)
	# Total SSE should be approx 0 due to normalization above;
	# sapply(1:ncol(xMat), function(i)
	# 	sapply(1:nrow(xMat), function(t)
	# 		(xMat[i, 1] - matrix(lambdaHat[i, ], nrow = 1) %*% matrix(fHat[t, ], ncol = 1))^2
	# 		) %>% sum(.)
	# 	) %>%
	# 	sum(.) %>%
	# 	{./(ncol(xMat) %*% nrow(xMat))}
	(xMat - (fHat %*% t(lambdaHat)))^1
	
	# Now test by R
	mseByR =
		sapply(1:bigN, function(r)
			sum((xMat - (fHat[, 1:r, drop = FALSE] %*% t(lambdaHat)[1:r, , drop = FALSE]))^2)/(bigT * bigN)
			)
	

	
	# Explained variance of data
	screeDf =
		fHat %>% cov(.) %>% diag(.) %>%
		{lapply(1:length(.), function(i)
			tibble(
				factors = i,
				var_explained = .[i],
				pct_of_total = .[i]/totalVar,
				cum_pct_of_total = sum(.[1:i])/totalVar
				)
			)} %>%
		dplyr::bind_rows(.) %>%
		dplyr::mutate(., mse = mseByR) %>%
		dplyr::mutate(
			.,
			ic1 = (mse) + factors * (bigN + bigT)/(bigN * bigT) * log((bigN * bigT)/(bigN + bigT)),
			ic2 = (mse) + factors * (bigN + bigT)/(bigN * bigT) * log(bigCSquared),
			ic3 = (mse) + factors * (log(bigCSquared)/bigCSquared)
		)
	
	bigR =
		# screeDf %>%
		# dplyr::filter(cum_pct_of_total >= .50) %>%
		# head(., 1) %>%
		# .$factor
		screeDf %>%
		dplyr::filter(., ic1 == min(ic1)) %>%
		.$factors
	
	
	zDf =
		xDf[, 'obsDate'] %>%
		dplyr::bind_cols(
			.,
			fHat[, 1:bigR] %>% as.data.frame(.) %>% setNames(., paste0('f', 1:bigR))
			)
	
	
	ef$nc$screeDf <<- screeDf
	ef$nc$bigR <<- bigR
	ef$nc$pcaInputDf <<- xDf
	ef$nc$zDf <<- zDf
})
```

## Run as VAR(1)
```{r}
local({
	
	inputDf =
		ef$nc$zDf %>%
    	econforecasting::addLags(., 1, TRUE) %>%
		na.omit(.)
	yMat = inputDf %>% dplyr::select(., -contains('.l'), -obsDate) %>% as.matrix(.)
	xDf = inputDf %>% dplyr::select(., contains('.l')) %>% dplyr::bind_cols(constant = 1, .)
	
	# solve(t(xMat) %*% xMat) %*% (t(xMat) %*% yMat)
	coefDf =
		lm(yMat ~ . - 1, data = xDf) %>%
		coef(.) %>%
		as.data.frame(.) %>%
		rownames_to_column(., 'coefname') %>%
		as_tibble(.) 
	
	bMat = coefDf %>% dplyr::filter(., coefname != 'constant') %>% dplyr::select(., -coefname) %>% t(.)
	cMat = coefDf %>% dplyr::filter(., coefname == 'constant') %>% dplyr::select(., -coefname) %>% t(.)
	qMat =
		lm(yMat ~ . - 1, data = xDf) %>%
	    residuals(.) %>% 
		as_tibble(.) %>%
		purrr::transpose(.) %>%
		lapply(., function(x) as.numeric(x)^2 %>% diag(.)) %>%
		{purrr::reduce(., function(x, y) x + y)/length(.)}
	
	
	ef$nc$qMat <<- qMat 
	ef$nc$bMat <<- bMat
	ef$nc$cMat <<- cMat
})
```

## Run DFM on monthly variables included in PCA
```{r}
local({
	
	yMat = ef$nc$pcaInputDf %>% dplyr::select(., -obsDate) %>% as.matrix(.)
	xDf = ef$nc$zDf %>% dplyr::select(., -obsDate)
	
	coefDf =
		lm(yMat ~ . - 1, xDf) %>%
		coef(.) %>%	
		as.data.frame(.) %>%
    	rownames_to_column(., 'coefname') %>%
		as_tibble(.)
	
	aMat = coefDf %>% dplyr::select(., -coefname) %>% t(.)
	
	rMat0 =
		lm(yMat ~ . - 1, data = xDf) %>%
	    residuals(.) %>% 
		as_tibble(.) %>%
		purrr::transpose(.) %>%
		lapply(., function(x) as.numeric(x)^2 %>% diag(.)) %>%
		{purrr::reduce(., function(x, y) x + y)/length(.)}
	
	rMatDiag = tibble(varname = ef$nc$pcaVarnames, variance = diag(rMat0))

	
	rMats =
		lapply(ef$nc$bigTauDates, function(d)
			sapply(ef$nc$pcaVarnames, function(v)
				ef$h$wide$m$stat %>%
					dplyr::filter(., obsDate == (d)) %>%
					.[[v]] %>% 
					{if (is.na(.)) 1e20 else dplyr::filter(rMatDiag, varname == v)$variance}
				) %>%
				diag(.)
			) %>%
		c(lapply(1:length(ef$nc$bigTDates), function(x) rMat0), .)

	ef$nc$rMats <<- rMats
	ef$nc$aMat <<- aMat
})
```

## Compute Kalman filter
```{r}
local({
	
	bMat = ef$nc$bMat
	cMat = ef$nc$cMat
	aMat = ef$nc$aMat
	rMats = ef$nc$rMats
	qMat = ef$nc$qMat
	yMats =
		dplyr::bind_rows(
			ef$nc$pcaInputDf,
			ef$h$wide$m$stat %>%
				dplyr::filter(., obsDate %in% ef$nc$bigTauDates) %>%
				dplyr::select(., obsDate, ef$nc$pcaVarnames)
			) %>%
		dplyr::mutate(., across(-obsDate, function(x) ifelse(is.na(x), 0, x))) %>%
		dplyr::select(., -obsDate) %>%
		purrr::transpose(.) %>%
		lapply(., function(x) matrix(unlist(x), ncol = 1))

	z0Cond0 = matrix(rep(0, ef$nc$bigR), ncol = 1)
	sigmaZ0Cond0 = matrix(rep(0, ef$nc$bigR^2), ncol = ef$nc$bigR)
		
	zTCondTMinusOne = list()
	zTCondT = list()
	
	sigmaZTCondTMinusOne = list()
	sigmaZTCondT = list()
	
	yTCondTMinusOne = list()
	sigmaYTCondTMinusOne = list()
	
	pT = list()

	for (t in 1:length(c(ef$nc$bigTDates, ef$nc$bigTauDates))) {
		# message(t)
		# Prediction Step
		zTCondTMinusOne[[t]] = bMat %*% {if (t == 1) z0Cond0 else zTCondT[[t-1]]} + cMat
		sigmaZTCondTMinusOne[[t]] = bMat %*% {if (t == 1) sigmaZ0Cond0 else sigmaZTCondT[[t-1]]} + qMat
		yTCondTMinusOne[[t]] = aMat %*% zTCondTMinusOne[[t]]
		sigmaYTCondTMinusOne[[t]] = aMat %*% sigmaZTCondTMinusOne[[t]] %*% t(aMat) + rMats[[t]]
		
		# Correction Step
		pT[[t]] = sigmaZTCondTMinusOne[[t]] %*% t(aMat) %*%
			{
				if (t %in% 1:length(ef$nc$bigTDates)) solve(sigmaYTCondTMinusOne[[t]])
				else chol2inv(chol(sigmaYTCondTMinusOne[[t]]))
				}
		zTCondT[[t]] = zTCondTMinusOne[[t]] + pT[[t]] %*% (yMats[[t]] - yTCondTMinusOne[[t]])
		sigmaZTCondT[[t]] = sigmaZTCondTMinusOne[[t]] - (pT[[t]] %*% sigmaYTCondTMinusOne[[t]] %*% t(pT[[t]]))
	}
	
	
	kFitted =
		zTCondT %>%
		purrr::map_dfr(., function(x)
			as.data.frame(x) %>% t(.) %>% as_tibble(.)
			) %>%
		dplyr::bind_cols(obsDate = c(ef$nc$bigTDates, ef$nc$bigTauDates), .) 
	
	
	## Smoothing step
	zTCondBigTSmooth = list()
	sigmaZTCondBigTSmooth = list()
	sT = list()
	
	for (t in (length(zTCondT) - 1): 1) {
		# message(t)
		sT[[t]] = sigmaZTCondT[[t]] %*% t(bMat) %*% solve(sigmaZTCondTMinusOne[[t + 1]])
		zTCondBigTSmooth[[t]] = zTCondT[[t]] + sT[[t]] %*% 
			({if (t == length(zTCondT) - 1) zTCondT[[t + 1]] else zTCondBigTSmooth[[t + 1]]} - zTCondTMinusOne[[t + 1]])
		sigmaZTCondBigTSmooth[[t]] = sigmaZTCondT[[t]] - sT[[t]] %*%
			(sigmaZTCondTMinusOne[[t + 1]] -
			 	{if (t == length(zTCondT) - 1) sigmaZTCondT[[t + 1]] else sigmaZTCondBigTSmooth[[t + 1]]}
			 ) %*% t(sT[[t]])
	}
	
	kSmooth =
		zTCondBigTSmooth %>%
		purrr::map_dfr(., function(x)
			as.data.frame(x) %>% t(.) %>% as_tibble(.)
			) %>%
		dplyr::bind_cols(obsDate = c(ef$nc$bigTDates, ef$nc$bigTauDates) %>% .[1:(length(.) - 1)], .) 
	
	
	
	
	## Forecasting step
	zTCondBigT = list()
	sigmaZTCondBigT = list()
	yTCondBigT = list()
	sigmaYTCondBigT = list()
	
	for (j in 1:length(ef$nc$bigTStarDates)) {
		zTCondBigT[[j]] = bMat %*% {if (j == 1) zTCondT[[length(zTCondT)]] else zTCondBigT[[j - 1]]} + cMat
		sigmaZTCondBigT[[j]] = bMat %*% {if (j == 1) sigmaZTCondT[[length(sigmaZTCondT)]] else sigmaZTCondBigT[[j - 1]]} + qMat
		yTCondBigT[[j]] = aMat %*% zTCondBigT[[j]]
		sigmaYTCondBigT[[j]] = aMat %*% sigmaZTCondBigT[[j]] %*% t(aMat) + rMats[[1]]
	}
	
	kForecast =
		zTCondBigT %>%
		purrr::map_dfr(., function(x)
			as.data.frame(x) %>% t(.) %>% as_tibble(.)
			) %>%
		dplyr::bind_cols(obsDate = ef$nc$bigTStarDates, .)
	

	
	# Plot and Cleaning
	kfPlots =
		lapply(colnames(ef$nc$zDf) %>% .[. != 'obsDate'], function(.varname)
			dplyr::bind_rows(
				dplyr::mutate(ef$nc$zDf, type = 'historical'),
				dplyr::mutate(kFitted, type = 'fitted'),
				dplyr::mutate(kForecast, type = 'forecast'),
				dplyr::mutate(kSmooth, type = 'smoothed'),
				) %>%
				tidyr::pivot_longer(., -c('obsDate', 'type'), names_to = 'varname') %>%
				dplyr::filter(., varname == .varname) %>%
				ggplot(.) +
				geom_line(aes(x = obsDate, y = value, color = type))
			)
	
	
	fDf = dplyr::bind_rows(kSmooth, tail(kFitted, 1), kForecast)
	yDf =
		yTCondBigT %>%
		purrr::map_dfr(., function(x) as_tibble(t(as.data.frame(x)))) %>%
		dplyr::bind_cols(obsDate = ef$nc$bigTStarDates, .)
	
	kfDf =
		yDf %>%
		dplyr::select(., obsDate, all_of(dplyr::filter(CONST$PARAMS, nowcast == 'kf')$varname))
	
	ef$nc$fDf <<- fDf
	ef$nc$kfPlots <<- kfPlots
	ef$nc$yDf <<- yDf
	ef$nc$kfDf <<- kfDf
})
```

## Add baseline forecasts from other page
```{r}
local({
  
	conn =
		dbConnect(
		RPostgres::Postgres(),
		dbname = CONST$DB_DATABASE,
		host = CONST$DB_SERVER,
		port = 5432,
		user = CONST$DB_USERNAME,
		password = CONST$DB_PASSWORD
		)
	
	reqs =
		tribble(
			~fcname, ~varname,
			'dns', 't10y',
			'dns', 't30y',
			'dns', 't05y',
			'dns', 't02y',
			'dns', 't01y',
			'dns', 't06m',
			'dns', 't03m',
			'dns', 't01m',
			'dns', 't20y',
			'dns', 't07y',
			'cme', 'ffr',
			'cme', 'sofr'
			)
	
	cmefiDf =
		DBI::dbGetQuery(conn, 'SELECT * FROM fc_forecast') %>%
		as_tibble(.) %>%
		dplyr::right_join(., reqs, by = c('fcname', 'varname')) %>%
		dplyr::group_by(., varname) %>%
		dplyr::filter(., vintage_date == max(vintage_date)) %>%
		dplyr::ungroup(.) %>%
		dplyr::select(., -vintage_date, -fcname) %>%
		dplyr::rename(., obsDate = obs_date) %>%
		dplyr::mutate(., freq = 'm') %>%
		# Only keep rows without a match in FRED data
		dplyr::anti_join(., ef$h$source$fred, by = c('varname', 'obsDate', 'freq')) %>%
		# Pivot
		dplyr::select(., -freq) %>%
		tidyr::pivot_wider(., names_from = varname, values_from = value) %>%
		dplyr::arrange(., obsDate) %>%
		dplyr::filter(., obsDate <= tail(ef$nc$bigTStarDates, 1))
	
	
  ef$nc$cmefiDf <<- cmefiDf
})
```

## Forecast dfm.m monthly variables
```{r}
local({
	
	dfmVarnames = CONST$PARAMS %>% dplyr::filter(., nowcast == 'dfm.m') %>% .$varname
	
	dfmMDf = 
		lapply(dfmVarnames, function(.varname) {
			inputDf =
				dplyr::inner_join(
					ef$nc$fDf,
					dplyr::select(ef$h$wide$m$stat, obsDate, all_of(.varname)),
					by = 'obsDate'
				) %>%
				na.omit(.)

			yMat = dplyr::select(inputDf, all_of(.varname)) %>% as.matrix(.)
			xDf = dplyr::select(inputDf, -obsDate, -all_of(.varname)) %>% dplyr::mutate(., constant = 1)

			coefDf =
				lm(yMat ~ . - 1, xDf)$coef %>%
	    		as.data.frame(.) %>% rownames_to_column(., 'coefname')	%>% as_tibble(.) %>%
				setNames(., c('coefname', 'value'))

			# Forecast dates + last historical date
			forecastDf0 =
				tibble(
					obsDate = seq(from = tail(inputDf$obsDate, 1), to = tail(ef$nc$bigTStarDates, 1), by = '1 month')
					) %>%
				.[2:nrow(.), ] %>%
				dplyr::mutate(., !!.varname := 0) %>%
				dplyr::left_join(., ef$nc$fDf, by = 'obsDate') %>%
				dplyr::bind_cols(., constant = 1)

			forecastDf =
				purrr::reduce(1:nrow(forecastDf0), function(accum, x) {
					accum[x, .varname] =
						accum[x, ] %>%
						dplyr::select(., coefDf$coefname) %>%
						matrix(., ncol = 1) %>%
						{matrix(coefDf$value, nrow = 1) %*% as.numeric(.)}

					return(accum)
				}, .init = forecastDf0) %>%
				dplyr::select(., all_of(c('obsDate', .varname)))
# 
# 			inputDf =
# 				dplyr::inner_join(
# 				ef$nc$fDf,
# 				dplyr::select(ef$h$wide$m$stat, obsDate, all_of(.varname)) %>%
# 					econforecasting::addLags(., 1, .zero = TRUE),
# 				by = 'obsDate'
# 				) %>%
# 				na.omit(.)
# 			
# 			yMat = dplyr::select(inputDf, all_of(.varname)) %>% as.matrix(.)
# 			xDf = dplyr::select(inputDf, -obsDate, -all_of(.varname)) %>% dplyr::mutate(., constant = 1)
# 			
# 			coefDf =
# 				lm(yMat ~ . - 1, xDf)$coef %>%
# 	    		as.data.frame(.) %>% rownames_to_column(., 'coefname')	%>% as_tibble(.) %>%
# 				setNames(., c('coefname', 'value'))
# 			
# 			# Forecast dates + last historical date
# 			forecastDf0 =
# 				tibble(
# 					obsDate = seq(from = tail(inputDf$obsDate, 1), to = tail(ef$nc$bigTStarDates, 1), by = '1 month')
# 					) %>%
# 				dplyr::mutate(., !!.varname := c(inputDf[[paste0(.varname, '.l1')]][[1]], rep(NA, nrow(.) - 1))) %>%
# 				dplyr::left_join(., ef$nc$fDf, by = 'obsDate') %>%
# 				dplyr::bind_cols(., constant = 1)
# 			
# 			forecastDf =
# 				purrr::reduce(2:nrow(forecastDf0), function(accum, x) {
# 					accum[x, .varname] =
# 						accum %>% econforecasting::addLags(., 1, .zero = TRUE) %>%
# 						.[x, ] %>%
# 						dplyr::select(., coefDf$coefname) %>%
# 						matrix(., ncol = 1) %>%
# 						{matrix(coefDf$value, nrow = 1) %*% as.numeric(.)}
# 					
# 					return(accum)
# 				}, .init = forecastDf0) %>%
# 				.[2:nrow(.), ] %>%
# 				dplyr::select(., all_of(c('obsDate', .varname)))
		
			}) %>%
			purrr::reduce(., function(accum, x) dplyr::full_join(accum, x, by = 'obsDate')) %>%
			dplyr::arrange(., obsDate)


	
	ef$nc$dfmMDf <<- dfmMDf	
})
```

## Forecast dfm.q quarterly variables
```{r}
local({
	
	dfmVarnames = CONST$PARAMS %>% dplyr::filter(., nowcast == 'dfm.q') %>% .$varname
	
	fDf =
		ef$nc$fDf %>%
		tidyr::pivot_longer(., -obsDate, names_to = 'varname') %>%
		dplyr::mutate(
			.,
			q = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))
			) %>%
		dplyr::select(., -obsDate) %>%
		dplyr::group_by(., varname, q) %>%
		dplyr::summarize(., value = mean(value)) %>%
		tidyr::pivot_wider(., names_from = varname, values_from = value) %>%
		dplyr::rename(., obsDate = q)
	
	
	dfmQDf =
		lapply(dfmVarnames, function(.varname) {
			
	# 		inputDf =
	# 			dplyr::inner_join(
	# 				fDf,
	# 				dplyr::select(ef$h$wide$q$stat, obsDate, all_of(.varname)),
	# 				by = 'obsDate'
	# 			) %>%
	# 			na.omit(.)
	# 
	# 		yMat = dplyr::select(inputDf, all_of(.varname)) %>% as.matrix(.)
	# 		xDf = dplyr::select(inputDf, -obsDate, -all_of(.varname)) %>% dplyr::mutate(., constant = 1)
	# 
	# 		coefDf =
	# 			lm(yMat ~ . - 1, xDf)$coef %>%
	#     		as.data.frame(.) %>% rownames_to_column(., 'coefname')	%>% as_tibble(.) %>%
	# 			setNames(., c('coefname', 'value'))
	# 
	# 		# Forecast dates + last historical date
	# 		forecastDf0 =
	# 			tibble(
	# 				obsDate = seq(from = tail(inputDf$obsDate, 1), to = tail(ef$nc$bigTStarDates, 1), by = '3 months')
	# 				) %>%
	# 			.[2:nrow(.), ] %>%
	# 			dplyr::mutate(., !!.varname := 0) %>%
	# 			dplyr::left_join(., ef$nc$fDf, by = 'obsDate') %>%
	# 			dplyr::bind_cols(., constant = 1)
	# 
	# 		forecastDf =
	# 			purrr::reduce(1:nrow(forecastDf0), function(accum, x) {
	# 				accum[x, .varname] =
	# 					accum[x, ] %>%
	# 					dplyr::select(., coefDf$coefname) %>%
	# 					matrix(., ncol = 1) %>%
	# 					{matrix(coefDf$value, nrow = 1) %*% as.numeric(.)}
	# 
	# 				return(accum)
	# 			}, .init = forecastDf0) %>%
	# 			dplyr::select(., all_of(c('obsDate', .varname)))

			inputDf =
				dplyr::inner_join(
					fDf,
					dplyr::select(ef$h$wide$q$stat, obsDate, all_of(.varname)) %>%
						econforecasting::addLags(., 1, .zero = TRUE),
					by = 'obsDate'
				) %>%
				na.omit(.)

			yMat = dplyr::select(inputDf, all_of(.varname)) %>% as.matrix(.)
			xDf = dplyr::select(inputDf, -obsDate, -all_of(.varname)) %>% dplyr::mutate(., constant = 1)

			coefDf =
				lm(yMat ~ . - 1, xDf)$coef %>%
	    		as.data.frame(.) %>% rownames_to_column(., 'coefname')	%>% as_tibble(.) %>%
				setNames(., c('coefname', 'value'))

			# Forecast dates + last historical date
			forecastDf0 =
				tibble(
					obsDate = seq(from = tail(inputDf$obsDate, 1), to = tail(ef$nc$bigTStarDates, 1), by = '3 months')
					) %>%
				dplyr::mutate(., !!.varname := c(inputDf[[paste0(.varname, '.l1')]][[1]], rep(NA, nrow(.) - 1))) %>%
				dplyr::left_join(., ef$nc$fDf, by = 'obsDate') %>%
				dplyr::bind_cols(., constant = 1)

			forecastDf =
				purrr::reduce(2:nrow(forecastDf0), function(accum, x) {
					accum[x, .varname] =
						accum %>% econforecasting::addLags(., 1, .zero = TRUE) %>%
						.[x, ] %>%
						dplyr::select(., coefDf$coefname) %>%
						matrix(., ncol = 1) %>%
						{matrix(coefDf$value, nrow = 1) %*% as.numeric(.)}

					return(accum)
				}, .init = forecastDf0) %>%
				.[2:nrow(.), ] %>%
				dplyr::select(., all_of(c('obsDate', .varname)))
			}) %>%
			purrr::reduce(., function(accum, x) dplyr::full_join(accum, x, by = 'obsDate')) %>%
			dplyr::arrange(., obsDate)

	
	ef$nc$dfmQDf <<- dfmQDf
})
```


# Finalize Nowcasts

## Aggregate
```{r}
local({
	
	dfM =
		list(ef$nc$dfmMDf, ef$nc$cmefiDf) %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)
	
	dfQ =
		list(ef$nc$dfmQDf) %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)


	ef$ncpred0$wide$m$stat <<- dfM
	ef$ncpred0$wide$q$stat <<- dfQ
})
```


## Detransform
```{r}
local({
	
	dfM =
		ef$ncpred0$wide$m$stat %>%
		{lapply(colnames(.) %>% .[. != 'obsDate'], function(.varname) {
			
			transform = dplyr::filter(CONST$PARAMS, varname == .varname)$stat
			
			fcDf = dplyr::select(., obsDate, .varname) %>% na.omit(.)
				
			histDf = tail(dplyr::filter(na.omit(ef$h$wide$m$base[, c('obsDate', .varname)]), obsDate < min(fcDf$obsDate)), 1)
			
			fcDf %>%
				dplyr::mutate(
					.,
					!!.varname := 
						{
	                        if (transform == 'dlog') undlog(fcDf[[2]], histDf[[2]])
							else if (transform == 'base') .[[2]]
							else stop('Err: ', .varname)
							}
						)
			
			})} %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)
	
	
	dfQ =
		ef$ncpred0$wide$q$stat %>%
		{lapply(colnames(.) %>% .[. != 'obsDate'], function(.varname) {
			
			transform = dplyr::filter(CONST$PARAMS, varname == .varname)$stat
			
			fcDf = dplyr::select(., obsDate, .varname) %>% na.omit(.)
				
			histDf = tail(dplyr::filter(na.omit(ef$h$wide$q$base[, c('obsDate', .varname)]), obsDate < min(fcDf$obsDate)), 1)
			
			fcDf %>%
				dplyr::mutate(
					.,
					!!.varname := 
						{
	                        if (transform == 'dlog') undlog(fcDf[[2]], histDf[[2]])
							else if (transform == 'base') .[[2]]
							else stop('Err: ', .varname)
							}
						)
			
			})} %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)
	

	ef$ncpred0$wide$m$base <<- dfM
	ef$ncpred0$wide$q$base <<- dfQ
})
```

## Calculate GDP nowcast
```{r}
local({
	
	dfQ =
		ef$ncpred0$wide$q$base %>%
		dplyr::transmute(
			.,
			obsDate,
			govt = govtf + govts,
			ex = exg + exs,
			im = img + ims,
			nx = ex - im,
			pdin = pdinstruct + pdinequip + pdinip,
			pdi = pdin + pdir + pceschange,
			pces = pceshousing + pceshealth + pcestransport + pcesrec + pcesfood + pcesfinal + pcesother + pcesnonprofit,
			pcegn = pcegnfood + pcegnclothing + pcegngas + pcegnother,
			pcegd = pcegdmotor + pcegdfurnish + pcegdrec + pcegdother,
			pceg = pcegn + pcegd,
			pce = pceg + pces,
			gdp = pce + pdi + nx + govt
		)
	
	dfM =
		ef$ncpred0$wide$m$base %>%
		dplyr::transmute(
			.,
			obsDate,
			psr = ps/pid
		)
	
	ef$ncpred1$wide$m$base <<- dfM
	ef$ncpred1$wide$q$base <<- dfQ
})
```

## Aggregate & calculate display format
```{r}
local({
	
	wide = list()
	
	wide$m$base =
		list(ef$ncpred0$wide$m$base, ef$ncpred1$wide$m$base) %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)

	wide$q$base =
		list(ef$ncpred0$wide$q$base, ef$ncpred1$wide$q$base) %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)

	
	wide$m$display =
		wide$m$base %>%
		{lapply(colnames(.) %>% .[. != 'obsDate'], function(.varname) {
			
			transform = dplyr::filter(CONST$PARAMS, varname == .varname)$display
			fcDf = dplyr::select(., obsDate, .varname) %>% na.omit(.)
			
			histDf = tail(dplyr::filter(na.omit(ef$h$wide$m$base[, c('obsDate', .varname)]), obsDate < min(fcDf$obsDate)), 1)
			
			dplyr::bind_rows(histDf, fcDf) %>%
				dplyr::mutate(
					.,
					!!.varname := 
						{
	                        if (transform == 'apchg') apchg(.[[2]], 12)
							else if (transform == 'base') .[[2]]
							else stop('Err: ', .varname)
							}
						) %>%
				.[2:nrow(.), ]
			
			})} %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)

	
	wide$q$display =
		wide$q$base %>%
		{lapply(colnames(.) %>% .[. != 'obsDate'], function(.varname) {
			
			transform = dplyr::filter(CONST$PARAMS, varname == .varname)$display
			fcDf = dplyr::select(., obsDate, .varname) %>% na.omit(.)
			
			histDf = tail(dplyr::filter(na.omit(ef$h$wide$q$base[, c('obsDate', .varname)]), obsDate < min(fcDf$obsDate)), 1)
			
			dplyr::bind_rows(histDf, fcDf) %>%
				dplyr::mutate(
					.,
					!!.varname := 
						{
	                        if (transform == 'apchg') apchg(.[[2]], 4)
							else if (transform == 'base') .[[2]]
							else stop('Err: ', .varname)
							}
						) %>%
				.[2:nrow(.), ]
			
			})} %>%
		purrr::reduce(., function(x, y) dplyr::full_join(x, y, by = 'obsDate')) %>%
		dplyr::arrange(., obsDate)

	
	ef$ncpred$wide <<- wide
})
```

## Save to RDS
```{r}
local({
	
	saveRDS(list(CONST = CONST, ef = ef), file = file.path(DIR, 'nowcast.rds'))
	
	
})
```




