# Set Constants
```{r}
DIR = 'D:/Onedrive/__Projects/econforecasting'
PACKAGE_DIR = 'D:/Onedrive/__Projects/econforecasting/econforecasting'
DL_DIR = 'D:/Onedrive/__Projects/econforecasting/tmp'
RESET_ALL = FALSE
```


# Initialize
```{r}
library(tidyverse)
library(devtools)
library(jsonlite)
library(lubridate)
library(httr)
library(rvest)
library(DBI)

setwd(DIR)

if (dir.exists(DL_DIR)) unlink(DL_DIR, recursive = TRUE)
dir.create(DL_DIR, recursive = TRUE)

source(file.path(DIR, 'constants.r'))
CONST$PARAMS = readxl::read_excel('inputs.xlsx')

devtools::load_all(path = PACKAGE_DIR)
devtools::document(PACKAGE_DIR)

ef = list(
  h = list(),
  f = list()
)
```


# Get Historical Data

## From FRED
```{r}
local({
  
	# Run in console to get list of GDP subcomponents
	# httr::GET('https://fred.stlouisfed.org/release/tables?rid=53&eid=14961#snid=14966') %>%
	# 	httr::content(.) %>%
	# 	rvest::html_nodes('#release-elements-tree tbody tr') %>%
	# 	map_dfr(., function(x)
	# 		tibble(
	# 			a =
	# 				x %>% rvest::html_nodes('td') %>% .[3] %>%
	# 				html_text(.) %>% str_replace_all(., '\n', '') %>% trimws(.),
	# 			fred =
	# 				x %>% rvest::html_nodes('td') %>% .[3] %>%
	# 				rvest::html_nodes('span a') %>% rvest::html_attr('href') %>% str_replace(., '/series/', '')
	# 			)
	# 		)
	
	df =
		CONST$PARAMS %>%
		purrr::transpose(.) %>%
		setNames(., lapply(., function(x) x$varname)) %>%
		lapply(., function(x) {
		  message('Getting data ... ', x$varname)
		  econforecasting::getDataFred(x$fredname, CONST$FRED_API_KEY, .freq = 'q', .returnVintages = FALSE) %>%
		    dplyr::mutate(., varname = x$varname, freq = 'q') %>%
		    {if (x$freq %in% c('d', 'm'))
		      dplyr::bind_rows(
		        .,
		        econforecasting::getDataFred(x$fredname, CONST$FRED_API_KEY, .freq = 'm', .returnVintages = FALSE) %>%
		          dplyr::mutate(., varname = x$varname, freq = 'm')
		        )
		      else .
		    } %>%
		    {if (x$freq %in% c('d'))
		      dplyr::bind_rows(
		        .,
		        econforecasting::getDataFred(x$fredname, CONST$FRED_API_KEY, .freq = 'd', .returnVintages = FALSE) %>%
		          dplyr::mutate(., varname = x$varname, freq = 'd')
		        )
		      else .
		    }
		}) %>%
		dplyr::bind_rows(.) %>%
		dplyr::filter(., obsDate >= as.Date('2000-01-01'))


	ef$h$source$fred <<- df
})
```

## Aggregate raw data
```{r}
local({
	ef$h$sourceDf <<- dplyr::bind_rows(ef$h$source)
})
```

# Seasonal & Stationary Transformations

## Deseasonalize
```{r}
local({
	
	seasDf =
		ef$h$sourceDf %>%
		dplyr::filter(., varname == 'hpils') %>%
		dplyr::mutate(
			.,
			seas = 
			{ts(.$value, start = c(year(.$obsDate[1]), month(.$obsDate[1])), freq = 12)} %>%
			seasonal::seas(.) %>%
			predict(.)
			) %>%
		dplyr::select(., -value)
	
	df =
		dplyr::left_join(ef$h$sourceDf, seasDf, by = c('obsDate', 'varname', 'freq')) %>%
		dplyr::mutate(., value = ifelse(is.na(seas), value, seas)) %>%
		dplyr::select(., -seas)

	ef$h$seasDf <<- df
})
```

## Stationary transformations
```{r}
local({

	flat = list()
	flat$base = ef$h$seasDf
	
	flat$stat =
		ef$h$seasDf %>%
		dplyr::left_join(., CONST$PARAMS[, c('varname', 'stat_transform')], by = c('varname')) %>%
		dplyr::group_by(varname, freq) %>%
		dplyr::group_split(.) %>%
		lapply(., function(x)
			x %>%
				dplyr::arrange(., obsDate) %>%
				dplyr::mutate(
					.,
					value = {
						if (head(., 1)$stat_transform == 'base') value
						else if (head(., 1)$stat_transform == 'dlog') dlog(value)
						else if (head(., 1)$stat_transform == 'diff1') diff1(value)
						else if (head(., 1)$stat_transform == 'diff2') diff2(value)
						else if (head(., 1)$stat_transform == 'ma2') ma2(value)
						else if (head(., 1)$stat_transform == 'lma2') lma2(value)
						else if (head(., 1)$stat_transform == 'apchg') apchg(value)
						else stop ('Error')
						}
					)
			) %>%
		dplyr::bind_rows(.) %>%
		dplyr::select(., -stat_transform)
	
	
	
	ef$h$flat <<- flat
	ef$h$flatDf <<- purrr::imap_dfr(flat, function(x, transform) x %>% mutate(., transform = transform)) 
})
```

## Create monthly/quarterly matrixes
```{r}
local({
	
	wide =
		ef$h$flatDf %>%
		as.data.table(.) %>%
		split(., by = 'freq') %>%
		lapply(., function(x)
			split(x, by = 'transform') %>%
				lapply(., function(y)
					as_tibble(y) %>%
						dplyr::select(., -freq, -transform) %>%
						tidyr::pivot_wider(., names_from = varname)
					)
			)

	
	ef$h$wide <<- wide	
})
```


# Nowcast

## Get monthly versions of quarterly factors
```{r}
local({
	

	
	
})
```

Get monthly versions of GDP subcomponents ->
	Using DFM on some, SEM on others. Divide by 3 to get "monthly" dlog estimates -> loop through each quarter, adjust all monthly dlog values such that all dlog values must sumn correctly. ((1+m1+x)(1+m2+x)(1+m3+x) = (1+q)) => Solve for x. Get all base values
	
-> after monthly calcs, can 
	
	dlog.gdp = dlog.pce * pce_1/gdp_1 + dlog.gpdi * gpdi/gpdi_1 + dlog.exports * exports1/gdp + dlog.gvt * gvt/gdp
dplyr::filter(ef$h$wide$q$stat, obsDate >= as.Date('2010-01-01')) %>% lm(pdinr ~ (pce) + ma2(ue) + ma2(vsales) + ma2(spy) + lma2(loanscc), data = .) %>% summary(.)



dplyr::filter(ef$h$wide$q$stat, obsDate >= as.Date('2010-01-01')) %>% lm(gdp ~ pce + ue + vsales, data = .) %>% residuals(.) %>% dplyr::bind_cols( dplyr::filter(ef$h$wide$q$stat, obsDate >= as.Date('2010-01-01')), resids = .) %>% dplyr::transmute(., obsDate,  gdp = gdp * 400, pce = pce * 400, ue, resids = resids * 400) %>% View(.)



-> first estim ate components of GDP monthly
```{r}
local({
	
	lm(as.matrix(yDf) ~ ., data = xDf[, 1:6]) %>% residuals(.) %>% plot(.)
	
	ef$h$wide$q$base %>%
    	dplyr::filter(., obsDate >= as.Date('2010-01-01')) %>% lm(gdp ~ pce + ue, data = .) %>% summary(.)
})
```



```{r}
local({
fDf %>% dplyr::mutate(., quarter = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))) %>% dplyr::select(., -obsDate) %>% pivot_longer(., -quarter) %>% dplyr::group_by(quarter, name) %>% summarize(., value = mean(value)) %>% tidyr::pivot_wider(., names_from = name, values_from = value) %>% ungroup(.) %>% dplyr::inner_join(., ef$h$wide$q$stat[, c('obsDate', 'gdp')], by = c('quarter' = 'obsDate'))
})
```


## Extract factors
```{r}
local({
	
	xDf =
		ef$h$wide$m$stat %>%
		dplyr::filter(., obsDate >= as.Date('2010-01-01')) %>%
		dplyr::select(., where(function(x) !any(is.na(x))))
	
	xMat =
		xDf %>%
		dplyr::select(., -obsDate) %>%
		as.matrix(.) %>%
		scale(.)
	
	lambdaHat = eigen(t(xMat) %*% xMat) %>% .$vectors
	fHat = (xMat) %*% lambdaHat
	
	# Total variance of data
	totalVar = xMat %>% cov(.) %>% diag(.) %>% sum(.)
	
	# Explained variance of data
	varDf =
		fHat %>% cov(.) %>% diag(.) %>%
		{lapply(1:length(.), function(i)
			tibble(
				factor = i,
				var_explained = .[i],
				pct_of_total = .[i]/totalVar,
				cum_pct_of_total = sum(.[1:i])/totalVar
				)
			)} %>%
		dplyr::bind_rows(.)
	
	bigR =
		varDf %>%
		dplyr::filter(cum_pct_of_total >= .90) %>%
		head(., 1) %>%
		.$factor
	
	
	fDf =
		xDf[, 'obsDate'] %>%
		dplyr::bind_cols(
			.,
			fHat[, 1:bigR] %>% as.data.frame(.) %>% setNames(., paste0('f', 1:bigR))
			)
	
	
	ef$nc$fDf <<- fDf
})
```

##  
```{r}
local({
	# Aggregate factors by quarter and then 
	quarterlyFDf =
		fDf %>%
		dplyr::mutate(
			.,
			quarter = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))
			) %>%
		dplyr::select(., -obsDate) %>%
		pivot_longer(., -quarter) %>%
		dplyr::group_by(quarter, name) %>%
		dplyr::summarize(., value = mean(value)) %>%
		tidyr::pivot_wider(., names_from = name, values_from = value) %>%
		dplyr::ungroup(.)
	
	
	
	CONST$PARAMS %>% dplyr::filter(., freq == 'q') %>% .$varname %>% as.list(.) %>%
		lapply(., function(x) {
			inputDf =
				ef$h$wide$q$stat[, c('obsDate', x)] %>%
				dplyr::inner_join(., quarterlyFDf, by = c('obsDate' = 'quarter')) %>%
				dplyr::mutate(., lag := lag(.[[x]], 1)) %>% 
				na.omit(.)
			
			yDf = inputDf %>% dplyr::select(., all_of(x))
			xDf = inputDf %>% dplyr::select(., -c('obsDate', x))

			lm(as.matrix(yDf) ~ ., data = xDf[, 1:5]) %>% residuals(.) %>% plot(.)
			})
	
	lm(as.matrix(yDf) ~ ., data = xDf[, 1:5]) %>% residuals(.) %>% plot(.)

	
})
```


## Determine dates to be nowcasted & forecasted
```{r}
local({
	
	ef$h$fred %>%
		dplyr::group_by(varname) %>%
		dplyr::filter(., obsDate == max(obsDate) & freq == 'm') %>%
		dplyr::left_join(., dplyr::select(CONST$PARAMS, varname, key_input), by = 'varname') %>%
		dplyr::filter(., key_input == TRUE) %>%
		dplyr::ungroup(.)
	
fDf %>% dplyr::mutate(., quarter = econforecasting::strdateToDate(paste0(lubridate::year(obsDate), 'Q', lubridate::quarter(obsDate)))) %>% dplyr::select(., -obsDate) %>% pivot_longer(., -quarter) %>% dplyr::group_by(quarter, name) %>% summarize(., value = mean(value)) %>% tidyr::pivot_wider(., names_from = name, values_from = value) %>% ungroup(.) %>% dplyr::inner_join(., ef$h$wide$q$stat[, c('obsDate', 'gdp')], by = c('quarter' = 'obsDate')) %>% dplyr::select(., -quarter) %>% lm(gdp ~ lma2(gdp) + ., data = .) %>% summary(.)

})
```


## De-seasonalize
```{r}
local({
	
	getDataFred('MEDLISPRIUS', CONST$FRED_API_KEY) %>% {ts(.$value, start = c(year(.$obsDate[1]), month(.$obsDate[1])), freq = 12)} %>% seasonal::seas(.) %>% predict(.) %>% as_tibble(.) %>% plot(.)

})
```

